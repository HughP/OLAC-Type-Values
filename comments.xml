<!-- Greetings,

Collegues and I are working on the catalogs of several instutional repositories. We are doing some data conformaty checking and some quality assurance assement with the goal of providing clarifing feedback to the govening body of the application profile in use. The application is Dublin Core with the addition of several specified vocabualires. If this is not the most appropiate list please someone PM me and let me know. I see that most of the discussion here relates to MARC but our catalogs are mostly in Dublin Core.
The application profile we are working with was created in the era of Qualified Dublin Core. Currently the DCMI usage board advocates the DC Abstract Model, but data providers in our network are still strongly connected to a QDC understanding of Dublin Core. I have at least two questions: 

1: Does it make sense to apply literal and non-literal types to the values of qualified Dublin Core elements? DCTerms are indicated to be non-literials (pointers). For data verification this is an important issue.
2. Can DCTerms qualify other DCTerms, for example via xsi:type or is there a namespace constraint against this?




Qualified Dublin Core, is the concept that DCTerms was a namespace defined to create descriptors (adjectives or qualifiers) which narrow the scope of a DC Element. All entities in the DC1.1 namespace are elements. "Elements" as a term comes from an understanding of the DC entities expressed via XML, however these entities are more appropriately called properties. DCMES= Dublin Core Metadata Elements Set, is the set of elements/properties which are not qualifiers. Following the freezing the 1.1 namespace, additional "Elements" were acknowledged which were not qualifiers. These were added to the DCTerms namespace. Therefore the DCTerms namespace contains both some elements and all the qualifiers. In the ensuing development of the Dublin Core Metadata Set (both the 1.1 and DCTerms namespaces), another concept emerged. That is, is the value of an element is a literal or a non-literal. Non-literals are pointers to other things, whereas literals point no further and are therefore the thing. Most DCTerms are defined as requiring non-literals. All DC 1.1 elements are defined as being able to take both literal or non-literal values, though this doesn't make sense in some cases. For example, dc:date doesn't makes sense as a non-literal unless one accepts as date something like "the hundred and twenty years war" and then defines that text string in another namespace, which is not the our use-case (though in archeology this may be more common practice where time is conceptually periods rather than years). Considering the data value typing differences between qualifiers in the DCTerms namespace and the elements of the 1.1 namespace, a crucial distinction between the uses of the namespaces emerges. Namely, use pointers with the DCTerms namespace. When working with QDC two important questions emerge: 1) does an XML xsi:type declaration convert a DC element to a DCTerms as that is what is being told to the XML parser — including the change from literal to non-literal on the datatype OR can an XML element with a DC element in the 1.1 namespace be qualified with any namespace and still remain a literal? 2) The second, question which arises is: can properties in the DCTerms namespace modify other properties in the DCTerms namespace via the XML xsi:type attribute? The answer to this may be "yes", "no", or "in some cases".  If "yes", then can rights be modified with coverage:spacial to indicate the jurisdiction of where rights apply? If "no", then why does the QDC apply to dcterms:uri to dcterms:spatial? Or sometimes, are there some cases, such as syntaxes which can be applied to dcterms but no other cases? Therefore do syntaxes create inferable classes within in the DCTerms namespace? -->

<!-- XML Comments preceed the element or section they apply to. Comments created by Hugh Paterson III. Primitives include: QDC= Qualified Dublin Core, This is the concept that DCTerms was a namespace defined to create descriptors (adjectives or qualifiers) which narrow the scope of a DC Element. All entities in the DC1.1 namespace are elements. "Elements" as a term comes from an understanding of the DC entities expressed via XML, however these entities are more appropriately called properties. DCMES= Dublin Core Metadata Elements Set, which is the set of elements which are not qualifiers. Following the DCMI usage board's choices to freeze the 1.1 namespace additional "Elements" were needed which were not qualifiers. These were added to the DCTerms namespace. Therefore the DCTerms namespace contains both some elements and all the qualifiers. In the ensuing development of the Dublin Core Metadata Set (both the 1.1 and DCTerms namespaces), another concept emerged. That is, is the value of an element is a literal or a non-literal. Non-literals are pointers to other things, whereas literals point no further and are therefore the thing. Most DCTerms are defined as requiring non-literals. All DC 1.1 elements are defined as being able to take both literal or non-literal values, though this doesn't make sense in some cases. For example, dc:date doesn't makes sense as a non-literal unless one accepts as date something like "the hundred and twenty years war" and then defines that text string in another namespace, which is not the OLAC use-case (though in archeology this may be more common practice where time is conceptually periods rather than years). A practice of using epoc labels as dates mitigates against a cataloging best practice of defining dates in specific formats. It is better in these cases to say that something is "date unknown" and has a coverage definition of the label of the epoc. Considering the data value typing differences between qualifiers in the DCTerms namespace and the elements of the 1.1 namespace, a crucial distinction between the uses of the namespaces emerges. Namely, use pointers with the DCTerms namespace. When working with QDC two important questions emerge: 1) does an XML xsi:type declaration convert a DC element to a DCTerms as that is what is being told to the XML parser — including the change from literal to non-literal on the datatype OR can an XML element with a DC element in the 1.1 namespace be qualified with any namespace and still remain a literal? 2) The second, question which arises is: can properties in the DCTerms namespace modify other properties in the DCTerms namespace via the XML xsi:type attribute? The answer to this may be "yes", "no", or "in some cases".  If yes, then can rights be modified with coverage:spatial to indicate the jurisdiction of where rights apply. If no, then why does the QDC apply to dcterms:uri to dcterms:spacial? Or sometimes, are there some cases, such as syntaxes which can be applied to dcterms but no other cases? Therefore do syntaxes create inferable classes within in the DCTerms namespace?  See question here: https://stackoverflow.com/questions/74966725/can-two-xsitype-attributes-exist-in-the-same-element-->
